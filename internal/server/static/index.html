<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gofit</title>
	<style type="text/css">
		.hidden {
			display: none;
		}

	</style>
	<div id="currentMovement" class="hidden"> </div>
	<div id="movement" class="hidden"> </div>
	<div id="reps" class="hidden"> </div>
	<div id="time" class="hidden"> </div>
	<div>
		<button id="startButton" class="hidden" onClick="start()">Start</button>
		<button id="pauseButton" class="hidden" onClick="pause()">Pause</button>
		<button id="resumeButton" class="hidden" onClick="resume()">Resume</button>
	</div>
	<div id="auth">
		<label for="usernameInput">Username:</label>
		<input id="usernameInput" type="text" />
		<label for="passwordInput">Password:</label>
		<input id="passwordInput" type="password" />
		<button id="loginButton" onClick="login()">Login</button>
		<button id="registerButton" onClick="register()">Register</button>
	</div>

	<audio id="timeTickSound" src="beep.mp3"></audio>
	<audio id="startSound" src="start.mp3"></audio>
	<audio id="stopSound" src="stop.mp3"></audio>
	<audio id="successSound" src="success.mp3"></audio>
</head>

<body>

	<script>
		let workout = [{name: "squat", reps: 2, duration: 4}, {name: "lying hamstring stretch", reps: 2, duration: 10}];
		let timer, timerId, currentReps, movementSecondsRemaining;
		let msBetweenReps = 2000;
		let msBeforeReps = 2000;
		let currentMovement = 0;
		init();

		function init() {
			getSession();
		}

		function getSession() {
			fetch(location.pathname + 'session')
				.then((response) => {
					if (!response.ok) {
						throw new Error(`HTTP error ${response.status}`);
					}
					return response.text(); // Or `.json()` or one of the others
				})
				.then((data) => {
					res = JSON.parse(data);
					document.getElementById("auth").classList.add("hidden");
					nowStr = new Date().toLocaleDateString();
					if (res.workoutDay != nowStr) {
						console.log("Session's workout was for a prior day, fetching a new one");
						fetchWorkout();
						return
					}
					if (res.doneForTheDay) {
						document.getElementById("currentMovement").innerText = "Done for the day!";
						return
					}
					workout = res.workout.movements;
					currentMovement = res.workout.done;
					currentReps = 0;
					setCurrentMovementText();
					document.getElementById("startButton").classList.remove("hidden");
				}).catch(() => { });
		}

		function fetchWorkout() {
			nowStr = new Date().toLocaleDateString();
			fetch(location.pathname + 'workout', {method: "POST", body: JSON.stringify(nowStr)})
				.then((response) => {
					if (!response.ok) {
						throw new Error(`HTTP error ${response.status}`);
					}
					return response.text(); // Or `.json()` or one of the others
				})
				.then((data) => {
					res = JSON.parse(data);
					workout = res.movements;
					currentMovement = res.done;
				}).catch(() => { }).finally(() => {
					currentReps = 0;
					setCurrentMovementText();
					document.getElementById("startButton").classList.remove("hidden");
				});
		}

		function sendServerWorkoutUpdate() {
			fetch(location.pathname + 'workoutUpdate', {method: "POST"})
				.then((response) => {
					if (!response.ok) {
						throw new Error(`HTTP error ${response.status}`);
					}
					return response.text(); // Or `.json()` or one of the others
				}).catch(() => { });
		}

		function setCurrentMovementText() {
			document.getElementById("currentMovement").classList.remove("hidden");
			document.getElementById("currentMovement").innerText =
				"Movement: " + workout[currentMovement].name + " (" + (currentMovement + 1) + " / " + workout.length + ")";
		}

		function setRepsText() {
			document.getElementById("reps").classList.remove("hidden");
			document.getElementById("reps").innerText = "Reps: " + (currentReps + 1) + " / " + workout[currentMovement].reps;
		}

		function setTimeText(time) {
			document.getElementById("time").classList.remove("hidden");
			document.getElementById('time').innerText = "Time: " + time;
		}

		function start() {
			timer = new Timer();
			document.getElementById("startButton").classList.add("hidden");
			document.getElementById("pauseButton").classList.remove("hidden");
			document.getElementById("auth").classList.add("hidden");
			startRep(workout[currentMovement]);
		}

		function pause() {
			timer.stop()
			document.getElementById("pauseButton").classList.add("hidden");
			document.getElementById("resumeButton").classList.remove("hidden");
		}
		function resume() {
			timer.start()
			document.getElementById("resumeButton").classList.add("hidden");
			document.getElementById("pauseButton").classList.remove("hidden");
		}

		function register() {
			creds = {
				username: document.getElementById("usernameInput").value,
				password: document.getElementById("passwordInput").value
			};
			fetch(location.pathname + 'register', {
				method: "POST",
				body: JSON.stringify(creds),
			})
				.then((response) => {
					if (!response.ok) {
						throw new Error(`HTTP error ${response.status}`);
					}
					return response.text(); // Or `.json()` or one of the others
				})
				.then((data) => {
					document.getElementById("auth").classList.add("hidden");
					fetchWorkout();
				}).catch(() => { });
		}

		function login() {
			creds = {
				username: document.getElementById("usernameInput").value,
				password: document.getElementById("passwordInput").value
			};
			fetch(location.pathname + 'session', {
				method: "POST",
				body: JSON.stringify(creds),
			})
				.then((response) => {
					if (!response.ok) {
						throw new Error(`HTTP error ${response.status}`);
					}
					return response.text(); // Or `.json()` or one of the others
				})
				.then((data) => {
					document.getElementById("auth").classList.add("hidden");
					fetchWorkout();
				}).catch(() => { });
		}

		function startRep(movement) {
			timer.start();
			setRepsText();
			document.getElementById('startSound').play();
			timerId = setInterval(() => {
				const timerTime = timer.getTime();
				if (timerTime < msBeforeReps) {
					return;
				}
				const movementMs = movement.duration * 1000;
				const totalRepMs = movementMs + msBeforeReps + msBetweenReps;
				const newTimeRemaining = Math.ceil((movementMs - (timerTime - msBeforeReps)) / 1000);
				if (newTimeRemaining != movementSecondsRemaining && newTimeRemaining >= 0) {
					movementSecondsRemaining = newTimeRemaining;
					setTimeText(Math.min(movement.duration, movementSecondsRemaining));
					if (movementSecondsRemaining > 0) {
						document.getElementById('timeTickSound').play();
					} else if (movementSecondsRemaining == 0) {
						document.getElementById('stopSound').play();
					}
				}
				if (timer.getTime() >= totalRepMs) {
					currentReps++;
					clearInterval(timerId);
					if (currentReps < workout[currentMovement].reps) {
						timer.stop();
						timer.reset();
						startRep(movement);
					} else {
						nextMovement();
					}
				}
			}, 10)
		}

		function nextMovement() {
			sendServerWorkoutUpdate();
			currentReps = 0;
			currentMovement++;
			document.getElementById("pauseButton").classList.add("hidden");
			document.getElementById("time").classList.add("hidden");
			document.getElementById("reps").classList.add("hidden");
			if (currentMovement < workout.length) {
				document.getElementById("startButton").classList.remove("hidden");
				setCurrentMovementText();
			} else {
				document.getElementById("currentMovement").innerText = "Done for the day!";
				document.getElementById('successSound').play();
			}
		}


		class Timer {
			constructor() {
				this.isRunning = false;
				this.startTime = 0;
				this.overallTime = 0;
			}

			_getTimeElapsedSinceLastStart() {
				if (!this.startTime) {
					return 0;
				}
				return Date.now() - this.startTime;
			}

			start() {
				if (this.isRunning) {
					return console.error('Timer is already running');
				}
				this.isRunning = true;
				this.startTime = Date.now();
			}

			stop() {
				if (!this.isRunning) {
					return console.error('Timer is already stopped');
				}
				this.isRunning = false;
				this.overallTime = this.overallTime + this._getTimeElapsedSinceLastStart();
			}

			reset() {
				this.overallTime = 0;
				if (this.isRunning) {
					this.startTime = Date.now();
					return;
				}
				this.startTime = 0;
			}

			getTime() {
				if (!this.startTime) {
					return 0;
				}
				if (this.isRunning) {
					return this.overallTime + this._getTimeElapsedSinceLastStart();
				}
				return this.overallTime;
			}
		}
	</script>

</body>

</html>
